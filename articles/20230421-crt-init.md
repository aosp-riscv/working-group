![](./diagrams/linker-loader.png)

文章标题：**Global Constructors/Destructors**

- 作者：汪辰
- 联系方式：<unicorn_wang@outlook.com> / <wangchen20@iscas.ac.cn>

<!-- TOC -->

- [参考](#参考)

<!-- /TOC -->

记录一下自己对 Global Constructors/Destructors 的理解，感觉有些地方分析得还不是很深入，后面有机会再补上 FIXME。

# 参考

- [Ref 1]《程序员的自我修养-链接、装载与库》
- [Ref 2] [.init, .ctors, and .init_array][1]
- [Ref 3] [Why does GCC put calls to constructors of global instances into different sections (depending on the target)?][2]
- [Ref 4] [understanding the __libc_init_array][3]
- [Ref 5] [Initialization and Termination Sections][4]

参考 [Ref 1] 的 11.2.3 和 11.4 以及 [Ref 2]，我们知道由于 C++ 的出现和 ELF 文件的改进，需要在 `main()` 函数之前实现全局构造（Global Constructors）或者在 main 函数之后实现全局析构（Global Destructors）。对此提出的解决方案有两套：

一套方法是结合 `.init/.fini` 和 `.ctors/.dtors` 两组 section。`.init/.fini` 的机制我理解应该更早就出现了，只是为了一定的兼容性保留了下来，和后来发明的 `.ctors/.dtors` 组合起来完成我们的目的。而 `.init` 和 `.fini` section 中实际上就是定义了 `_init()` 和 `_fini()` 两个函数，只是这个函数的组成比较复杂，需要 C 库，C 编译器 和链接器通力合作，由 C 库中的 CRT 负责提供 `crti.o/crtn.o`（实现了 `_init()` 和 `_fini()` 的 prolog 和 epilog），GCC 负责提供 `crtbegin.o/crtend.o`（实现了 `__do_global_ctors_aux()`/`__do_global_dtor_aux()`），GCC 的编译器负责将代码中的全局/静态对象的构造和析构函数地址以函数指针的形式存放到 `.ctors/.dtors` section 中组成 `__CTOR_LIST__/__DTOR_LIST__` 两个函数指针数组供 `__do_global_ctors_aux()`/`__do_global_dtor_aux()` 访问，最后由链接器将这些 object 文件中的特殊的 section 收集起来，拼凑到可执行程序中。

从上面的描述可以发现该方法实现起来比较麻烦，容易出错，所以后来演进为第二套方案。

第二套方案引入另外一对 `.init_array` 和 `.fini_array` section。整个实现只需要编译器和链接器介入，不再需要涉及那些额外的 CRT 文件（譬如 `crti.o/crtn.o/crtbegin.o/crtend.o`）。而且具体实现时由编译器负责将全局构造和析构函数的指针放置在各自源文件对应的 object 文件的 `.init_array`/`.fini_array` section 中（这一点上和 `.ctors/.dtors` 的处理类似），最后在链接阶段由链接器将这些 section 整合起来形成一个统一的函数指针数组就好了，`crt1.o` 中直接可以直接访问该数组即可调用这些函数。另外第二套方案还提供了优先级处理，可以在定义构造和析构函数时指定可选的优先级（0~65535），数字越小，作为构造函数越优先执行，而作为析构则越晚被执行，如果不指定则默认优先级为 65535（在 C++ 中普通的全局类对象的构造和析构优先级也是 65535），具体可以参考下面的例子。

目前的系统大部分都迁移到了第二套方案，但在第二套方案的基础上我们还要补充了解两点：
- 为了兼容性考虑，在采用第二套方案后，在某些系统上仍然支持 `.init/.fini`。
- 大部分系统除了 `.init_array`/`.fini_array` 外，还支持 `.preinit_array`，注意这里并没有什么对应的 `.postfini_array` 存在。不支持的情况最典型的譬如 musl，[musl 就没有实现对 `.preinit_array` 的支持][5]，即使链接生成的可执行文件中包含有 `.preinit_array` 相关的 section，musl 也不会处理。

所以在目前大部分的系统上程序的执行过程大致如下：

```
-> `_init()`
-> 遍历 `.preinit_array`
-> 遍历 `.init_array`
-> `main()`
-> 遍历 `.fini_array`
-> `_fini()`
```

看一个实际的例子，例子的代码点击 [这里][6]：

```shell
$ g++ a.cpp b.cpp
$ ./a.out
a:ctor:101
b:ctor:101
a:ctor:102
b:ctor:102
a:ctor:65535
a:ctor:65535[class]
b:ctor:65535
main
a:dtor:65535[class]
b:dtor:65535
a:dtor:65535
b:dtor:102
a:dtor:102
b:dtor:101
a:dtor:101
```




[1]:https://maskray.me/blog/2021-11-07-init-ctors-init-array
[2]:https://stackoverflow.com/questions/28564078/why-does-gcc-put-calls-to-constructors-of-global-instances-into-different-sectio
[3]:https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array
[4]:https://docs.oracle.com/cd/E19683-01/817-3677/6mj8mbtb7/index.html#chapter2-48195
[5]:https://www.openwall.com/lists/musl/2015/11/29/7
[6]:./code/20230421-crt-init/